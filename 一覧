# ===== æ—¢å­˜ãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ =====
x_data = np.load("x_data.npy")[:9999]          # Î”tï¼ˆã‚¼ãƒ­ç‚¹é–“éš”ï¼‰
y_data             [:9999]                     #d/dt (DIRTæƒ…å ±é™ä¸‹)
primes = np.load("primes.npy")[:9999]          # ç´ æ•°åˆ—
kappa = np.load("kappa_list.npy")  [:9999]     # Îº(p)   kappa_list = 1 - (np.log(np.log(primes)) / np.log(primes))
info_potential = x_data * prime_density        #æƒ…å ±ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ« = Î”t Ã— ç´ æ•°å¯†åº¦
log_primes = np.log(primes)[:10000]
prime_density = 1 / np.log(primes)             # ç´ æ•°å¯†åº¦ = 1 / log(p)
stream_vectors.npy	ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ™ã‚¯ãƒˆãƒ«	Stream vectors	shape = (M, 3) â€“ ã‚¹ãƒ‘ã‚¤ã‚¯ç‚¹ (Îº, Î”t, prime_density) ã‚’ 3 ã‚¹ãƒ†ãƒƒãƒ—å¾Œã¨çµã¶å·®åˆ†ãƒ™ã‚¯ãƒˆãƒ«ã€‚å„è¡Œã¯ [Î”Îº, Î”Î”t, Î”Ï]ã€‚æ™‚ç©ºæƒ…å ±æµã® â€œå‘ãâ€ ã‚’ç¤ºã™
stream_cluster_labels.npy	ãƒ™ã‚¯ãƒˆãƒ«ã‚¯ãƒ©ã‚¹ã‚¿ãƒ©ãƒ™ãƒ«	Cluster labels for stream vectors	shape = (M,) â€“ DBSCAN ã«ã‚ˆã‚Š stream_vectors ã¨åŒã˜è¡Œé †ã§ä»˜ä¸ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¿IDã€‚-1 ã¯ãƒã‚¤ã‚ºï¼å¤–ã‚Œå€¤
ç”¨é€”ãƒ¡ãƒ¢
â€¢stream_vectors.npy ã¨ stream_cluster_labels.npy ã¯ãƒšã‚¢ã§æ‰±ã„ã€ã‚¯ãƒ©ã‚¹ã‚¿ã”ã¨ã®å¹³å‡ãƒ™ã‚¯ãƒˆãƒ«ã‚„å¯è¦–åŒ–ï¼ˆquiver plot ç­‰ï¼‰ã«åˆ©ç”¨ã€‚

å¤‰æ•°ä¸€è¦§ã« dc_dt ã‚’æ˜ç¤ºçš„ã«è¿½åŠ ã—ãŸæœ€æ–°ç‰ˆ

å¤‰æ•°å	æ„å‘³ï¼ˆæ—¥æœ¬èªï¼‰	Meaning (English)	è©³ç´°ã¨è¨ˆç®—ä¾‹ / Notes
x_data	é›¶ç‚¹é–“éš” Î”t ã®ç³»åˆ—	Zeroâ€spacing intervals Î”t	python\nx_data = np.load(\"x_data.npy\")[:9999]  # Time interval between consecutive zeros\n
y_data	å…ƒã®è¦³æ¸¬ç³»åˆ—ï¼ˆä¾‹ï¼šæƒ…å ±ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ« cï¼‰	Original observational series (e.g., information potential c)	python\ny_data = np.load(\"y_data.npy\")[:9999]  # Base time series used to derive dc_dt\n
dc_dt	æƒ…å ±é™ä¸‹ã®æ™‚é–“å¾®åˆ† dc/dt	Time derivative of information descent dc/dt	python\ndc_dt = np.load(\"dc_dt.npy\")[:9999]  # Pre-computed derivative of y_data\n
primes	å…ˆé ­ 9 999 å€‹ã®ç´ æ•°åˆ—	First 9 999 prime numbers	python\nprimes = np.load(\"primes.npy\")[:9999]\n
kappa	æ§‹é€ å¼·åº¦ Îº(p)	Structural intensity Îº(p)	python\nkappa = 1 - (np.log(np.log(primes)) / np.log(primes))\n# or\nkappa = np.load(\"kappa_list.npy\")\n

ä½¿ã„åˆ†ã‘ã®ãƒã‚¤ãƒ³ãƒˆ

ã‚«ãƒ†ã‚´ãƒª	é™çš„ï¼å‹•çš„	ä¸»ãªç”¨é€”
y_data	é™çš„ï¼ˆåŸç³»åˆ—ï¼‰	FFT ã‚„æ´¾ç”Ÿé‡è¨ˆç®—ã®å…¥åŠ›ã€åŸºæº–å€¤ã®å¯è¦–åŒ–
dc_dt	å‹•çš„ï¼ˆï¼‘éšå°é–¢æ•°ï¼‰	æ§‹é€ å´©å£Šç‚¹ã®æ¤œå‡ºã€ä¿å­˜æ€§ã®æ™‚é–“å¤‰å‹•è§£æ
x_data	é™çš„ï¼ˆÎ”t è»¸ï¼‰	æ¨ªè»¸ã¨ã—ã¦å…±é€šä½¿ç”¨ã€å‘¨æœŸæ€§è§£æã®åŸºæº–
primes, kappa	æº–é™çš„ï¼ˆé›¢æ•£æ§‹é€ ï¼‰	ç´ æ•°çš„ç§©åºæ€§ã®è©•ä¾¡ã€ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°è£œåŠ©ç‰¹å¾´


è§£æç”¨ npy ãƒ•ã‚¡ã‚¤ãƒ«ã¨ä½œæˆã•ã‚Œã‚‹ä¸»è¦å¤‰æ•°ã®ä¸€è¦§

â€• é«˜æ ¡ç”Ÿã§ã‚‚èª­ã‚ã‚‹ã‚ˆã†ã«ã€æ—¥è‹±å¯¾è¨³ã§è¦ç‚¹ã‚’æ•´ç†ã—ã¾ã—ãŸ â€•

å¤‰æ•° / ãƒ•ã‚¡ã‚¤ãƒ«	æ„å‘³ï¼ˆæ—¥æœ¬èªï¼‰	Meaning (English)	èª­ã¿è¾¼ã¿ä¾‹ / è¨ˆç®—å¼ãƒ»ç”¨é€”
x_data  â† x_data.npy	é›¶ç‚¹ï¼ˆã‚¼ãƒ­ç‚¹ï¼‰é–“éš” Î”t ã®ç³»åˆ—	Zeroâ€“spacing intervals Î”t	python x_data = np.load("x_data.npy")[:9999]æ¨ªè»¸ã«ä½¿ã†å…±é€šã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—
y_data  â† y_data.npy	å…ƒè¦³æ¸¬åˆ—ï¼ˆæƒ…å ±ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ« c ãªã©ï¼‰	Original observational series (e.g. info-potential c)	python y_data = np.load("y_data.npy")[:9999]FFTãƒ»å¾®åˆ†ã®åŸºãƒ‡ãƒ¼ã‚¿
dc_dt  â† dc_dt.npy	æƒ…å ±é™ä¸‹ã®æ™‚é–“å¾®åˆ† dc/dt	Time derivative of information descent dc/dt	python dc_dt = np.load("dc_dt.npy")[:9999]æ§‹é€ å´©å£Šç‚¹ã®æ¤œå‡ºã«ä½¿ç”¨
primes  â† primes.npy	å…ˆé ­ 9 999 å€‹ã®ç´ æ•°åˆ—	First 9 999 prime numbers	python primes = np.load("primes.npy")[:9999]é›¢æ•£ç§©åºæ€§ã®è§£æè»¸
kappa  â† kappa_list.npy	æ§‹é€ å¼·åº¦ Îº(p)	Structural intensity Îº(p)	python kappa = 1 - (np.log(np.log(primes))/np.log(primes))ã¾ãŸã¯äº‹å‰è¨ˆç®—å€¤ã‚’èª­ã¿è¾¼ã¿
energy_bins_hi  â† energy_bins_hi.npy	é«˜ã‚¨ãƒå´ bin ã‚¨ãƒƒã‚¸	High-energy bin edges	10â€“30 GeV è§£æã®å¯å¤‰å¢ƒç•Œ
hi_ref  â† hi_ref.npy	é«˜ã‚¨ãƒåŸºæº–ãƒ•ãƒ«ã‚¨ãƒ³ã‚¹	High-energy reference fluence	ä¿¡å· vs. èƒŒæ™¯ã®è¦æ ¼åŒ–ã«ä½¿ç”¨
energy_bins  â† energy_bins.npy	å…¨åŸŸã‚¨ãƒ bin ã‚¨ãƒƒã‚¸	Global energy-bin edges	å›³ãƒ»ãƒ’ã‚¹ãƒˆã‚°ãƒ©ãƒ å…±é€šã®æ¨ªè»¸
counts_obs  â† counts_obs.npy	è¦³æ¸¬ã‚¤ãƒ™ãƒ³ãƒˆæ•°ãƒ’ã‚¹ãƒˆ	Observed event counts	IceCube 10â€“30 GeV å®Ÿæ¸¬ã‚¹ãƒšã‚¯ãƒˆãƒ«
mcmc_chain  â† mcmc_chain.npy	MCMC ã‚µãƒ³ãƒ—ãƒ©é–	Posterior MCMC chain	Ï„_{det}, Îº, R_{lock} ãªã©ã®äº‹å¾Œåˆ†å¸ƒ


â¸»

ä½¿ã„åˆ†ã‘ã®ãƒã‚¤ãƒ³ãƒˆï¼ˆã¾ã¨ã‚ï¼‰

ã‚«ãƒ†ã‚´ãƒª	é™çš„ / å‹•çš„	ä¸»ãªç”¨é€”
y_data	é™çš„ï¼ˆåŸç³»åˆ—ï¼‰	FFTãƒ»æ´¾ç”Ÿé‡è¨ˆç®—ã®å…¥åŠ›ã€ã‚°ãƒ©ãƒ•åŸºæº–ç·š
dc_dt	å‹•çš„ï¼ˆä¸€æ¬¡å°é–¢æ•°ï¼‰	ä¿å­˜æ€§ã®æ™‚é–“å¤‰å‹•ãƒ»ãƒ”ãƒ¼ã‚¯æ¤œå‡º
x_data	é™çš„ï¼ˆÎ”t è»¸ï¼‰	ã™ã¹ã¦ã®æ™‚é–“ç³»ãƒ—ãƒ­ãƒƒãƒˆã®æ¨ªè»¸
primes, kappa	æº–é™çš„ï¼ˆé›¢æ•£æ§‹é€ ï¼‰	ç´ æ•°ç§©åºæ€§ã®è©•ä¾¡ã€ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ç‰¹å¾´é‡
energy_bins*, counts_obs	å®Ÿé¨“ç³»çµ±	ã‚¹ãƒšã‚¯ãƒˆãƒ«å›³ãƒ»ä¿¡å·å¯¾èƒŒæ™¯ã®è¨ˆç®—
mcmc_chain	è§£ææˆæœç‰©	ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¨å®šãƒ»å¯è¦–åŒ–ï¼ˆcorner plot ãªã©ï¼‰

Tips
	â€¢	ãƒ•ã‚¡ã‚¤ãƒ«åã¨å¤‰æ•°åã‚’ 1 : 1 ã§ä¿ã¤ã¨å†ç¾æ€§ãŒé«˜ã¾ã‚Šã¾ã™ã€‚
	â€¢	energy_bins ç³»ã¯ x è»¸ã€counts_obs ã¯ y è»¸ ã«ãã®ã¾ã¾æ¸¡ã›ã‚‹å½¢ã«ã—ã¦ãŠãã¨å¯è¦–åŒ–ãŒæ¥½ã§ã™ã€‚
å¤‰æ•°ãƒ»ãƒ•ã‚¡ã‚¤ãƒ«ä¸€è¦§ï¼ˆæ¦‚è¦ã¾ã¨ã‚ï¼‰

å¤‰æ•° / ãƒ•ã‚¡ã‚¤ãƒ«	æ—¥æœ¬èªã®æ„å‘³	English meaning	å½¢çŠ¶ãƒ»è¨ˆç®—æ–¹æ³• / Notes
x_data	é›¶ç‚¹é–“éš” Î”t	Zeroâ€“spacing Î”t	shape = (9 999,) -â€“ é€£ç¶šã™ã‚‹éè‡ªæ˜é›¶ç‚¹é–“ã®é–“éš”ã‚’ç§’(?)å˜ä½ã§ä¿æŒ
y_data	dI/dtï¼ˆDIRT æƒ…å ±é™ä¸‹é€Ÿåº¦ï¼‰	Information-descent rate dI/dt	shape = (9 999,) -â€“ DIRT ãƒ•ãƒ¬ãƒ¼ãƒ ã§ã®æƒ…å ±é‡å¤‰åŒ–ç‡
primes	ç´ æ•°åˆ— p	Prime numbers p	shape = (9 999,) -â€“ å…ˆé ­ 9 999 å€‹ã®ç´ æ•°
kappa	Îº(p)ï¼ˆç§©åºæŒ‡æ¨™ï¼‰	Order index Îº(p)	Îº = 1 âˆ’ ln ln p / ln p
log_primes	\ln p	Natural log of primes	shape = (10 000,) â€“ ä¸Šé™ 1 ä¸‡è¦ç´ ã§è¨ˆç®—
prime_density	ç´ æ•°å¯†åº¦ 1/ \ln p	Prime density 1/ \ln p	ç´ æ•°å®šç†ã«åŸºã¥ãè¿‘ä¼¼å¯†åº¦
info_potential	æƒ…å ±ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ«	Information potential	\text{info\_potential} = \Delta t \times (1/\ln p)
stream_vectors.npy	ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ™ã‚¯ãƒˆãƒ«	Stream vectors	shape = (M, 3) â€“ ã‚¹ãƒ‘ã‚¤ã‚¯ç‚¹ (Îº, Î”t, prime_density) ã‚’ 3 ã‚¹ãƒ†ãƒƒãƒ—å¾Œã¨çµã¶å·®åˆ†ãƒ™ã‚¯ãƒˆãƒ«ã€‚å„è¡Œã¯ [Î”Îº, Î”Î”t, Î”Ï]ã€‚æ™‚ç©ºæƒ…å ±æµã® â€œå‘ãâ€ ã‚’ç¤ºã™
stream_cluster_labels.npy	ãƒ™ã‚¯ãƒˆãƒ«ã‚¯ãƒ©ã‚¹ã‚¿ãƒ©ãƒ™ãƒ«	Cluster labels for stream vectors	shape = (M,) â€“ DBSCAN ã«ã‚ˆã‚Š stream_vectors ã¨åŒã˜è¡Œé †ã§ä»˜ä¸ã•ã‚ŒãŸã‚¯ãƒ©ã‚¹ã‚¿IDã€‚-1 ã¯ãƒã‚¤ã‚ºï¼å¤–ã‚Œå€¤

ç”¨é€”ãƒ¡ãƒ¢
	â€¢	stream_vectors.npy ã¨ stream_cluster_labels.npy ã¯ãƒšã‚¢ã§æ‰±ã„ã€ã‚¯ãƒ©ã‚¹ã‚¿ã”ã¨ã®å¹³å‡ãƒ™ã‚¯ãƒˆãƒ«ã‚„å¯è¦–åŒ–ï¼ˆquiver plot ç­‰ï¼‰ã«åˆ©ç”¨ã€‚
	â€¢	kappa, info_potential, prime_density ãªã©æ—¢å­˜ã‚¹ã‚«ãƒ©ãƒ¼ç³»åˆ—ã¯ã€ãƒ™ã‚¯ãƒˆãƒ«æˆåˆ†ã®ç‰©ç†çš„è§£é‡ˆï¼ˆç§©åºå¤‰åŒ–ãƒ»å¯†åº¦å¤‰åŒ–ï¼‰ã‚’ä¸ãˆã‚‹å‚ç…§è»¸ã¨ã—ã¦æ©Ÿèƒ½ã™ã‚‹ã€‚









â¸»

ğŸ“¦ 1. Overview of Distributed Files

File name	Purpose	Typical shape / dtype	Sample load
energy_bins.npy	Energyâ€bin edges for the low range (â‰ˆ 10â€“30 GeV)	(N + 1,), float64	python\nE_lo = np.load("energy_bins.npy")\n
energy_bins_hi.npy	Energyâ€bin edges for the high range (â‰ˆ 30â€“100 GeV)	(M + 1,), float64	python\nE_hi = np.load("energy_bins_hi.npy")\n
hi_ref.npy	Model spectrum on the highâ€energy side (expected counts Î¼)	(M,), float64	python\nmu_hi = np.load("hi_ref.npy")\n
counts_obs.npy	Observed event counts (low + high concatenated)	(N + M,), int32	python\nn_obs = np.load("counts_obs.npy")\n
mcmc_chain.npy	MCMC chain â†’ n_step Ã— n_walk Ã— n_param (0 = Ï„_det, 1 = k, 2 = Îº, â€¦)	(2500, 60, 3), float64	python\nchain = np.load("mcmc_chain.npy")\n
stream_vectors.npy	3-step stream vectors	(M, 3), float64	python\nvec = np.load("stream_vectors.npy")\n# each row = [Î”Îº, Î”Î”t, Î”Ï]\n
stream_cluster_labels.npy	DBSCAN labels for the stream vectors	(M,), int32	python\nlab = np.load("stream_cluster_labels.npy")\n

Notes
	â€¢	Binâ€edge arrays list the left and right edges of each energy bin (element 0 & 1 form the first bin).
	â€¢	hi_ref.npy stores only the model expectation, computed as
\mu_{\text{hi}} = \Phi(E_{\text{mid}})\,A_{\text{eff}}\,(4\pi)\,\Delta T.
	â€¢	Use stream_vectors.npy and stream_cluster_labels.npy together for quiver plots or cluster-wise meanâ€vector analysis.
	â€¢	lab == -1 marks noise/outliers.

â¸»

ğŸ”§ 2. Derived Variables Used in the Analyses

The five core variables below match the sample script; combining x_data, y_data, dc_dt, primes, and kappa (Îº) reproduces the phase analysis and DIRT parameter estimation.

Variable	Meaning (JP)	Meaning (EN)	Definition / code snippet
x_data	é›¶ç‚¹é–“éš” Î”t ç³»åˆ—	Zero-spacing intervals Î”t	python\nx_data = np.load("x_data.npy")[:9999]\n
y_data	åŸç³»åˆ— (æƒ…å ±ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ« c)	Original time series (info-potential c)	python\ny_data = np.load("y_data.npy")[:9999]\n
dc_dt	æƒ…å ±é™ä¸‹ã®æ™‚é–“å¾®åˆ† dc/dt	Time derivative of info-descent	python\ndc_dt = np.load("dc_dt.npy")[:9999]\n
primes	å…ˆé ­ 9999 å€‹ã®ç´ æ•°åˆ—	First 9999 prime numbers	python\nprimes = np.load("primes.npy")[:9999]\n
kappa	æ§‹é€ å¼·åº¦ Îº(p)	Structural intensity Îº(p)	python\nkappa = 1 - np.log(np.log(primes)) / np.log(primes)\n# or: kappa = np.load(\"kappa_list.npy\")\n
prime_density	ç´ æ•°å¯†åº¦ Ï(p)	Prime density Ï(p)	python\nprime_density = 1 / np.log(primes)\n
log_primes	log p ç³»åˆ—	Natural logs of primes	python\nlog_primes = np.log(primes)[:10000]\n
info_potential	æƒ…å ±ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ« c	Information potential c	python\ninfo_potential = x_data * prime_density\n

Usage Guidelines

Category	Static / Dynamic	Typical use
y_data	static	FFT, derived metrics, baseline plots
dc_dt	dynamic	Detect structural breakpoints, track preservation
x_data	static	Common x-axis for periodicity analysis
primes, kappa	quasi-static	Evaluate prime-order structure, clustering features
info_potential	static	Main series for phase extraction / FFT
prime_density, log_primes	quasi-static	Visualize prime regularity, generate info_potential
stream_vectors, stream_cluster_labels	dynamic (3-step streams)	Vector-field direction (â€œinformation flowâ€) & cluster analysis

*info_potential sometimes appears as an alias for y_data in scripts.
Prime density adopts the Riemann prime-number theorem approximation Ï(p) â‰ˆ 1/\ln p.

â¸»

ğŸš€ 3. Quick-Start Mini Script

import numpy as np
import matplotlib.pyplot as plt

# --- Load core data
E_lo  = np.load('energy_bins.npy')
E_hi  = np.load('energy_bins_hi.npy')
mu_hi = np.load('hi_ref.npy')
n_obs = np.load('counts_obs.npy')

# --- Mid-bin energies & residuals
E_mid_hi = 0.5 * (E_hi[:-1] + E_hi[1:])
residual = (n_obs[-len(mu_hi):] - mu_hi) / np.sqrt(mu_hi)

plt.loglog(E_mid_hi, residual, 'o')
plt.axhline(0, ls=':')
plt.xlabel('Energy [GeV]')
plt.ylabel('(obs âˆ’ Î¼) / âˆšÎ¼')
plt.tight_layout()
plt.show()

â¸»

ğŸ“¦ 1. é…å¸ƒãƒ•ã‚¡ã‚¤ãƒ«æ¦‚è¦

ãƒ•ã‚¡ã‚¤ãƒ«å	å½¹å‰²	å…¸å‹ shape / dtype	ã‚µãƒ³ãƒ—ãƒ«ãƒ­ãƒ¼ãƒ‰
energy_bins.npy	ä½ã‚¨ãƒãƒ«ã‚®ãƒ¼å¸¯ï¼ˆ10â€“30 GeV æƒ³å®šï¼‰ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼å¢ƒç•Œé…åˆ—	(N+1,), float64	python\nE_lo = np.load('energy_bins.npy')\n
energy_bins_hi.npy	é«˜ã‚¨ãƒãƒ«ã‚®ãƒ¼å¸¯ï¼ˆ30â€“100 GeVï¼‰ã®ã‚¨ãƒãƒ«ã‚®ãƒ¼å¢ƒç•Œé…åˆ—	(M+1,), float64	python\nE_hi = np.load('energy_bins_hi.npy')\n
hi_ref.npy	é«˜ã‚¨ãƒãƒ«ã‚®ãƒ¼å´ãƒ¢ãƒ‡ãƒ«ã‚¹ãƒšã‚¯ãƒˆãƒ«ï¼ˆæœŸå¾…å€¤ Î¼ï¼‰	(M,), float64	python\nmu_hi = np.load('hi_ref.npy')\n
counts_obs.npy	å®Ÿè¦³æ¸¬ã‚«ã‚¦ãƒ³ãƒˆï¼ˆä½ + é«˜ã‚’é€£çµæ¸ˆã¿ï¼‰	(N+M,), int32	python\nn_obs = np.load('counts_obs.npy')\n
mcmc_chain.npy	MCMC é€£é–ï¼ˆshape = n_step Ã— n_walk Ã— n_paramï¼‰0: $\tau_{\text{det}}$, 1: $k$, 2: $\kappa$ ãªã©	(2500, 60, 3), float64	python\nchain = np.load('mcmc_chain.npy')\n
stream_vectors.npy	ã‚¹ãƒˆãƒªãƒ¼ãƒ ãƒ™ã‚¯ãƒˆãƒ«ï¼ˆ3-step å·®åˆ†ï¼‰	(M, 3), float64	python\nvec = np.load('stream_vectors.npy')\n# each row = [Î”Îº, Î”Î”t, Î”Ï]\n
stream_cluster_labels.npy	ä¸Šè¨˜ãƒ™ã‚¯ãƒˆãƒ«ã® DBSCAN ãƒ©ãƒ™ãƒ«	(M,), int32	python\nlab = np.load('stream_cluster_labels.npy')\n

ãƒ¡ãƒ¢
å¢ƒç•Œé…åˆ—ã¯ã€Œã‚¨ãƒãƒ«ã‚®ãƒ¼ bin ã®å·¦å³ç«¯ã€ã‚’åˆ—æŒ™ã™ã‚‹å½¢å¼ã§ã™ï¼ˆä¾‹: 0 ç•ªç›®ã¨ 1 ç•ªç›®ã§ 1 ã¤ã® binï¼‰ã€‚
hi_ref.npy ã¯å¼ mu_hi = Î¦(E_mid) Â· A_eff Â· 4Ï€Î”T ã§è¨ˆç®—ã—ãŸ ãƒ¢ãƒ‡ãƒ«æœŸå¾…å€¤ ã®ã¿ã‚’æ ¼ç´ã—ã¦ã„ã¾ã™ã€‚
Quiver plot ã‚„ã€Œã‚¯ãƒ©ã‚¹ã‚¿åˆ¥å¹³å‡ãƒ™ã‚¯ãƒˆãƒ«ã€è§£æã«ãƒšã‚¢ã§ä½¿ç”¨ã—ã¾ã™ã€‚
lab == -1 ã¯ãƒã‚¤ã‚ºç‚¹ã€‚

â¸»

ğŸ”§ 2. è§£æã§ç”¨ã„ã‚‹æ´¾ç”Ÿå¤‰æ•°

ä»¥ä¸‹ 5 å¤‰æ•°ã¯æ—¢å‡ºã®ã‚µãƒ³ãƒ—ãƒ«ã‚¹ã‚¯ãƒªãƒ—ãƒˆã¨å¯¾å¿œã—ã¦ã„ã¾ã™ã€‚
x_data, y_data, dc_dt, primes, kappa (Îº) ã‚’ä½µç”¨ã™ã‚‹ã“ã¨ã§ ä½ç›¸è§£æ + DIRT ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿æ¨å®š ãŒå†ç¾å¯èƒ½ã§ã™ã€‚

å¤‰æ•°å	æ„å‘³ï¼ˆæ—¥æœ¬èªï¼‰	Meaning (English)	å®šç¾© / è¨ˆç®—ä¾‹
x_data	é›¶ç‚¹é–“éš” Î”t ç³»åˆ—	Zeroâ€“spacing intervals Î”t	python\nx_data = np.load('x_data.npy')[:9999]\n
y_data	åŸç³»åˆ— (æƒ…å ±ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ« c)	Original time series (info-potential c)	python\ny_data = np.load('y_data.npy')[:9999]\n
dc_dt	æƒ…å ±é™ä¸‹ã®æ™‚é–“å¾®åˆ† dc/dt	Time derivative of info-descent	python\ndc_dt = np.load('dc_dt.npy')[:9999]\n
primes	å…ˆé ­ 9999 å€‹ã®ç´ æ•°åˆ—	First 9999 prime numbers	python\nprimes = np.load('primes.npy')[:9999]\n
kappa	æ§‹é€ å¼·åº¦ Îº(p)	Structural intensity Îº(p)	python\nkappa = 1 - np.log(np.log(primes)) / np.log(primes)\n# ã¾ãŸã¯ kappa = np.load('kappa_list.npy')\n
prime_density	ç´ æ•°å¯†åº¦ Ï(p)	Prime density Ï(p)	python\nprime_density = 1 / np.log(primes)\n
log_primes	log p ã®ç³»åˆ—	Natural logs of primes	python\nlog_primes = np.log(primes)[:10000]\n
info_potential	æƒ…å ±ãƒãƒ†ãƒ³ã‚·ãƒ£ãƒ« c	Information potential c	python\ninfo_potential = x_data * prime_density\n

ä½¿ã„åˆ†ã‘ã®ç›®å®‰

ã‚«ãƒ†ã‚´ãƒª	é™çš„ / å‹•çš„	ä¸»ãªç”¨é€”
y_data	é™çš„	FFTãƒ»æ´¾ç”Ÿé‡è¨ˆç®—ã€åŸºæº–ãƒ—ãƒ­ãƒƒãƒˆ
dc_dt	å‹•çš„	æ§‹é€ å´©å£Šç‚¹ã®æ¤œå‡ºã€ä¿å­˜æ€§ãƒˆãƒ©ãƒƒã‚­ãƒ³ã‚°
x_data	é™çš„	å…±é€šæ¨ªè»¸ (å‘¨æœŸæ€§è§£æ)
primes, kappa	æº–é™çš„	ç´ æ•°çš„ç§©åºæ€§ã®è©•ä¾¡ã€ã‚¯ãƒ©ã‚¹ã‚¿ãƒªãƒ³ã‚°ç‰¹å¾´é‡
info_potential (= y_data)	é™çš„	ä½ç›¸æŠ½å‡ºãƒ»FFT ã®ä¸»ç³»åˆ—
prime_density, log_primes	æº–é™çš„	ç´ æ•°è¦å‰‡æ€§ã®å¯è¦–åŒ–ã€info_potential ç”Ÿæˆ
stream_vectors, stream_cluster_labels	å‹•çš„ï¼ˆ3-step ã‚¹ãƒˆãƒªãƒ¼ãƒ ï¼‰	â€œæƒ…å ±æµâ€ ã®å‘ãï¼ˆãƒ™ã‚¯ãƒˆãƒ«å ´ï¼‰ã¨ã‚¯ãƒ©ã‚¹ã‚¿è§£æ

è£œè¶³
	â€¢	info_potential ãŒ y_data ã®åˆ¥åã¨ã—ã¦è§£æã«ç™»å ´ã™ã‚‹å ´åˆãŒã‚ã‚Šã¾ã™ã€‚
	â€¢	ã€Œç´ æ•°å¯†åº¦ã€ã¯ãƒªãƒ¼ãƒãƒ³ç´ æ•°å®šç†ã®è¿‘ä¼¼ Ï(p) â‰ˆ 1/ln p ã‚’ç›´æ¡ç”¨ã—ã¦ã„ã¾ã™ã€‚
â¸»

ğŸš€ 3. ã™ãã«å‹•ã‹ã™ãƒŸãƒ‹ã‚³ãƒ¼ãƒ‰ä¾‹

import numpy as np
import matplotlib.pyplot as plt

# --- Load core data
E_lo  = np.load('energy_bins.npy')
E_hi  = np.load('energy_bins_hi.npy')
mu_hi = np.load('hi_ref.npy')
n_obs = np.load('counts_obs.npy')

# --- Midâ€bin energies & residuals
E_mid_hi = 0.5 * (E_hi[:-1] + E_hi[1:])
residual = (n_obs[-len(mu_hi):] - mu_hi) / np.sqrt(mu_hi)

plt.loglog(E_mid_hi, residual, "o")
plt.axhline(0, ls=":")
plt.xlabel("Energy [GeV]"); plt.ylabel("(obs - Î¼)/âˆšÎ¼")
plt.tight_layout(); plt.show()


â¸»